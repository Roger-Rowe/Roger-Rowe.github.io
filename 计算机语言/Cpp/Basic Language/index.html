<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="secret zone" href="http://rogerrowe.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="secret zone" href="http://rogerrowe.cn/atom.xml"><link rel="alternate" type="application/json" title="secret zone" href="http://rogerrowe.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="cpp,程序语言"><link rel="canonical" href="http://rogerrowe.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/Basic%20Language/"><title>C++ 基本语言 - Cpp - 计算机语言 | the Roger Rowe's = secret zone = v</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ 基本语言</h1><div class="meta"><span class="item" title="创建时间：2021-08-03 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-08-03T00:00:00+08:00">2021-08-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>3.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>3 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">the Roger Rowe's</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/006mPcdFly8gtyziw9xy9j31900u0q4u.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/006mPcdFly8gtyzj9syrpj318a0u0q6c.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/006mPcdFly8gtyyxbvnotj31c00u0jxw.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/006mPcdFly8gtyzp8h0q9j311v0u0grh.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/006mPcdFly8gtyyt5fbtfj31hc0u0tbk.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/006mPcdFly8gtyyq3wn4dj31ho0u0nae.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" itemprop="item" rel="index" title="分类于 计算机语言"><span itemprop="name">计算机语言</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/" itemprop="item" rel="index" title="分类于 Cpp"><span itemprop="name">Cpp</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://rogerrowe.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/Basic%20Language/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://q1.qlogo.cn/g?b=qq&nk=1175120797&s=640"><meta itemprop="name" content="Roger Rowe"><meta itemprop="description" content="v, 惟愿心里有火，眼中有光呀"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="secret zone"></span><div class="body md" itemprop="articleBody"><p>本文记录了 cpp 基本语言查缺补漏部分。</p><p>参考书籍：《C++ Primer 第五版》</p><p><span id="more"></span></p><h1 id="变量和基本类型"><a class="anchor" href="#变量和基本类型">#</a> 变量和基本类型</h1><h2 id="如何选择类型"><a class="anchor" href="#如何选择类型">#</a> 如何选择类型</h2><ul><li>明知值不为负时，选用无符号类型</li><li>优先使用 <code>int</code> 执行整数运算，如果超过，选择 <code>long long</code></li><li>在算术表达式中不使用 <code>char</code> 或者 <code>bool</code> ，非要使用的话，加上 <code>signed</code> 或 <code>unsigned</code></li><li>执行浮点数运算采用 <code>double</code> ，精度够且计算代价相差无几</li></ul><h2 id="切勿混用带符号类型和无符号类型"><a class="anchor" href="#切勿混用带符号类型和无符号类型">#</a> 切勿混用带符号类型和无符号类型</h2><p>如果说表达式既有带符号类型和无符号类型，当带符号类型为负时会出现异常结果，这是因为带符号数会自动转换成无符号数。</p><h2 id="变量的列表初始化"><a class="anchor" href="#变量的列表初始化">#</a> 变量的列表初始化</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">units_sold</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> units_sold <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> units_sold<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>作为 C++11 新标准的一部分，用花括号来初始化变量得到了全面应用。当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们<mark>使用列表初始化且初始值存在丢失信息的风险时，编译器将报错</mark>。</p><h2 id="概念静态类型"><a class="anchor" href="#概念静态类型">#</a> 概念：静态类型</h2><p>C++ 是一种<mark>静态类型</mark>语言，其含义是在编译阶段进行类型检查。</p><h2 id="c关键字查缺补漏"><a class="anchor" href="#c关键字查缺补漏">#</a> C++ 关键字查缺补漏</h2><figure class="highlight cpp"><figcaption data-lang="C++"><span>alignas&alignof</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//alignas 设置内存中对齐方式，最小是 8 字节对齐，可以是 16，32，64，128 等</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//alignof 求变量在内存中的对齐方式</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 注意这里对齐的修饰对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">char</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>asm</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//asm 内嵌汇编语句</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Intel 与 AT&amp;T 可选</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// e.g.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">"mov eax, 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">asm</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">"mov eax, 1\n"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token string">"leave\n"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token string">"ret\n"</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>mutable</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 如果类的成员函数不会改变对象的状态，那么这个成员函数一半会声明成 const</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 但如果需要修改跟类状态无关的数据成员，那么这个数据成员就应该由 mutable 修饰</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">example</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//const 函数需要修改与类状态无关的变量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">outPut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// ...</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 改变类状态无关的变量</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token operator">++</span>iTimes<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    	<span class="token keyword">mutable</span> iTimes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="引用"><a class="anchor" href="#引用">#</a> 引用</h2><p>引用即别名，非对象。必须赋初值，不能更改。</p><h2 id="const-限定符"><a class="anchor" href="#const-限定符">#</a> const 限定符</h2><ol><li>对普通变量的 const 限定：</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确，运行时初始化</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>          <span class="token comment">// 正确，编译时初始化，即进行替换</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>              <span class="token comment">// 错误，未初始化</span></pre></td></tr></table></figure><ol start="2"><li>const 限定符只在本文件有效，若要在多文件共享，需加上 extern 关键字</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// file_1.cc</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufsize <span class="token operator">=</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// file_2.cc</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufsize<span class="token punctuation">;</span>         <span class="token comment">// 这两个文件的 bufsize 是同一个</span></pre></td></tr></table></figure><ol start="3"><li>对 const 引用简称为 “常量引用”。明确 const 限定符只是引用变量的自我约束（约束自己不修改自己的引用对象）（引用对象是常量则是两情相悦，引用对象不是常量就是一厢情愿），明确引用即别名（即可以通过它来修改变量）。</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> ki <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>kqi1 <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">// 正确，const 只是引用的一厢情愿</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>kqi2 <span class="token operator">=</span> ki<span class="token punctuation">;</span>    <span class="token comment">// 正确，正统的两情相悦</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>kqi3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 正确，对象是一个临时常量</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span>qi1 <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment">// 正确，引用即别名</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span>qi2 <span class="token operator">=</span> ki<span class="token punctuation">;</span>           <span class="token comment">// 错误，引用是别名，无法修改常量</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;</span>qi3 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token comment">// 错误，引用是别名，无法修改一个临时常量</span></pre></td></tr></table></figure><ol start="4"><li>const 指针，阅读方式为从右往左阅读。</li></ol><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 使用时常量要遵循初始化的要求。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>          <span class="token comment">// 是指针，指向一个常量 int，自我约束不修改指向的内容</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p2<span class="token punctuation">;</span>         <span class="token comment">// 是常量，这个常量是指针</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p3<span class="token punctuation">;</span>   <span class="token comment">// 是常量，这个常量是指针，指向一个常量 int（自以为的）</span></pre></td></tr></table></figure><ol start="5"><li>顶层 const 可以理解为变量本身的 const 属性，底层 const 理解为隐藏在变量之下的变量（如指针指向的变量、引用所引用的对象）的 const 属性。前者可以用普通 const 限定符考究，后者则是记住顶层对底层的可修改性确定是否能够这样赋值。</li><li>constexpr 常量表达式（作用于指针时，它是顶层的，显而易见，需要在编译期间得到地址值）：加此限定符保证表达式是由常量构成（能够在编译期就能确定的值，不一定需要字面值，也可以是由 constexpr 组成的）。</li></ol><h2 id="类型别名"><a class="anchor" href="#类型别名">#</a> 类型别名</h2><ol><li><code>typedef Sales_item SI</code></li><li><code>using SI = Sales_item</code></li></ol><div class="note default"><p>注意 <code>const</code> 对别名的修饰，是别名的顶级 <code>const</code></p></div><h2 id="auto-类型说明符"><a class="anchor" href="#auto-类型说明符">#</a> auto 类型说明符</h2><ul><li>引用是属于变量的别名，auto 推断时并不会推出来，故需要一个引用要显式地加上</li><li>auto 一般会忽略顶层 const，如果需要要显式地加上 const；底层的 const 会保存下来</li><li>符号 &amp; 和 * 从属于某个声明符，故初始值必须为同一类型。</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> ki <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 错误，前者来说 auto 被推断为 int，后者因为底层 const 被保留被推断为 const int</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 所以类型不一致，故错误</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>ki<span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="decltype-类型指示符"><a class="anchor" href="#decltype-类型指示符">#</a> decltype 类型指示符</h2><p>（C++ 11 新增 C++ 14 取消）通过 decltype 推出变量的类型。auto 是要利用初始化来推测，而 decltype 则不然。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// decltype(declared type)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 如果表达式是变量，返回变量的类型（包括顶层 const 和 引用 在内。</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//x 类型是 const int</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//y 类型是 const int &amp;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>nj<span class="token punctuation">)</span> z<span class="token punctuation">;</span>     <span class="token comment">// 错误，引用类型需要初始化</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 对于指针解引用（生成左值）得到的是引用变量</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//c 的类型是 int&amp; 而不是 int</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">//decltype 普通变量加括号得到的可作为左值赋值语句的特殊表达式</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//d 的类型是 int&amp;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span>      <span class="token comment">//e 的类型是 int</span></pre></td></tr></table></figure><h1 id="表达式"><a class="anchor" href="#表达式">#</a> 表达式</h1><h2 id="算术类型转换"><a class="anchor" href="#算术类型转换">#</a> 算术类型转换</h2><ul><li>先整型提升 （比 int 小的转换至 int）</li><li>对于相同大小的有符号与无符号的变量转换至无符号</li><li>对于不同大小的，谁表示大的转换至谁</li></ul><h2 id="其他类型的隐式转换"><a class="anchor" href="#其他类型的隐式转换">#</a> 其他类型的隐式转换</h2><ol><li>数组转换至指针（在 <code>decltype</code> <code>&amp;</code> <code>sizeof</code> <code>typeid</code> 不会发生）</li><li>转换成 bool 类型</li><li>转换至常量</li><li>指针至 void 相关转换</li></ol><h2 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// cast-name&lt;type>(expression)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// cast-name: static_cast, dynamic_cast, const_cast, reinterpret_cast</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 旧式的显示转换 (type) expr type (expr) 难以调试不建议使用</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// static_cast</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">double</span> slope <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//const_cast 改变底层 const，不再一厢情愿地不修改</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">//reinterpret_cast 重新解释一个指针，非常危险</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// 对于这个操作权限交予程序员</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="函数"><a class="anchor" href="#函数">#</a> 函数</h1><h2 id="含有可变参数的形参"><a class="anchor" href="#含有可变参数的形参">#</a> 含有可变参数的形参</h2><p><code>initializer_list&lt;type&gt; ls</code> 具有若干操作</p><h2 id="函数的默认参数"><a class="anchor" href="#函数的默认参数">#</a> 函数的默认参数</h2><ol><li>可以对部分进行参数默认，一旦一个参数默认，其后所有的参数都得默认实参</li><li>可以对函数进行重新声明，此时不能修改原有实参，只能在原函数参数列表中没有默认实参的新添加默认实参</li><li>在函数调用时，只能从前往后依次更改默认实参的值。（要求设计时经常需要自定义参数的参数出现在前面）</li></ol><h2 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h2><p>同一作用域内几个函数名字相同而形参列表不同称之为<strong>重载（overload）函数</strong>。</p><p>对于形参列表来说，顶层 const 不区分而区分底层 const.</p><h2 id="函数参数匹配"><a class="anchor" href="#函数参数匹配">#</a> 函数参数匹配</h2><ol><li>精确匹配<ul><li>实参类型和形参类型相同。</li><li>实参从数组类型或函数类型转换至相对应的指针类型</li><li>向实参中添加或删除顶层 const</li></ul></li><li>通过 const 转换实现的匹配</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换或指针转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ol><h2 id="关于返回"><a class="anchor" href="#关于返回">#</a> 关于返回</h2><div class="note default"><p>在含有 return 语句循环的后面也应该有 return 语句。很多编译器无法发现这种错误。</p></div><p>尾置返回类型 <code>auto func(int i) -&gt; int(*)[10];</code></p><h2 id="inline-函数与-constexpr-函数"><a class="anchor" href="#inline-函数与-constexpr-函数">#</a> inline 函数与 constexpr 函数</h2><h3 id="inline-函数"><a class="anchor" href="#inline-函数">#</a> inline 函数</h3><p>内联函数在每个调用点 “内联地” 展开。内联说明只是向编译器发起请求，编译器可以忽略这个请求。</p><h3 id="constexpr-函数"><a class="anchor" href="#constexpr-函数">#</a> constexpr 函数</h3><p>constexpr 要求返回值类型和所有形参的类型都是字面值类型，而且函数体中有且只有一条 return 语句。C++ 不要求 constexpr 函数必须返回常量表达式，但要求 constexpr 函数一定时可以在编译期间就确定返回值的（必须可以返回常量表达式）。</p><h2 id="调试帮助"><a class="anchor" href="#调试帮助">#</a> 调试帮助</h2><ol><li><code>assert(expression)</code></li><li>依赖于预处理变量 <code>NDEBUG</code> ，也可自定义调试 bug</li></ol><div class="tags"><a href="/tags/cpp/" rel="tag"><i class="ic i-tag"></i> cpp</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/" rel="tag"><i class="ic i-tag"></i> 程序语言</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-09-07 14:59:06" itemprop="dateModified" datetime="2021-09-07T14:59:06+08:00">2021-09-07</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Roger Rowe <i class="ic i-at"><em>@</em></i>secret zone</li><li class="link"><strong>本文链接：</strong> <a href="http://rogerrowe.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/Basic%20Language/" title="C++ 基本语言">http://rogerrowe.cn/计算机语言/Cpp/Basic Language/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006mPcdFly8gtyzpoqzb8j31hc0u0dhi.jpg" title="📖 剑指offer刷题笔记(二)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 剑指 offer</span><h3>📖 剑指offer刷题笔记(二)</h3></a></div><div class="item right"><a href="/%E5%B0%8F%E6%96%87%E7%AB%A0/Mumber/2021-8-summary/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006mPcdFly8gtyzp8h0q9j311v0u0grh.jpg" title="2021年中总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Mumber</span><h3>2021年中总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">如何选择类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E5%8B%BF%E6%B7%B7%E7%94%A8%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">切勿混用带符号类型和无符号类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">变量的列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">概念：静态类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E5%85%B3%E9%94%AE%E5%AD%97%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">C++ 关键字查缺补漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">const 限定符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.8.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">1.9.</span> <span class="toc-text">auto 类型说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype-%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.10.</span> <span class="toc-text">decltype 类型指示符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">算术类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">其他类型的隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">显式转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-number">3.1.</span> <span class="toc-text">含有可变参数的形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">函数的默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">3.4.</span> <span class="toc-text">函数参数匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BF%94%E5%9B%9E"><span class="toc-number">3.5.</span> <span class="toc-text">关于返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0%E4%B8%8E-constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">inline 函数与 constexpr 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">inline 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">constexpr 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">3.7.</span> <span class="toc-text">调试帮助</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/Basic%20Language/" rel="bookmark" title="C++ 基本语言">C++ 基本语言</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/cppCode/" rel="bookmark" title="个人代码风格形成记录">个人代码风格形成记录</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Cpp/cppSTL/" rel="bookmark" title="C++ STL的简单使用">C++ STL的简单使用</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Roger Rowe" data-src="https://q1.qlogo.cn/g?b=qq&nk=1175120797&s=640"><p class="name" itemprop="name">Roger Rowe</p><div class="description" itemprop="description">惟愿心里有火，眼中有光呀</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87offer2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E5%B0%8F%E6%96%87%E7%AB%A0/Mumber/2021-8-summary/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Roger Rowe @ the Roger Rowe's</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div><div class="powered-by"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbi8=">赣ICP备2021006772号</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"计算机语言/Cpp/Basic Language/",favicon:{show:"欸嘿嘿你回来啦 ( ͡° ͜ʖ ͡°)✧",hide:"别晾着人家啊喂 ٩(͡๏̯͡๏)۶"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>